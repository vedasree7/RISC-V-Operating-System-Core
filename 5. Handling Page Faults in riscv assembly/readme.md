
### Demand Paging and Page Fault Handling in RISC-V

This project component builds upon the virtual memory foundation established in earlier labs by implementing dynamic page fault handling in Machine Mode. The goal is to simulate an operating system’s behavior of resolving page faults by swapping in code or data pages and updating the page tables accordingly.

---

#### Objective

Implement a trap handler in Machine Mode to manage instruction and data page faults generated by user-level code. The handler dynamically maps virtual pages to physical frames and ensures correct address translation on subsequent accesses.

---

#### Problem Description

When a user-mode process accesses an unmapped virtual page, a page fault is triggered. Your task is to:

1. Detect and classify the page fault (instruction or data).
2. Dynamically allocate and initialize the required physical page.
3. Update the corresponding Level 0 page table entry.
4. Resume execution seamlessly after the fault is resolved.

---

#### Key Implementation Requirements

- **Instruction Page Faults**
  - Triggered by execution at an unmapped virtual address.
  - Allocate a new physical page.
  - Copy the contents of the *user code page* at physical address `0x80001000` to the new page.
  - Update the page table to map the faulting virtual page to this physical page.

- **Data Page Faults**
  - Triggered by accessing unmapped data addresses.
  - Map the faulting virtual address to the *user data page* at `0x80002000`.

- **Trap Handler Logic (in Machine Mode)**
  - Examine `mcause`, `mtval`, and `mepc` to classify the fault.
  - Compute the index into the Level 0 page table based on the virtual address.
  - Modify the page table dynamically—**do not hardcode indices**.
  - Return from the trap to retry the faulting instruction.

- **Address Range**
  - Your handler must support faults within the virtual address space `0x00000000` to `0x00010000`.

---

#### Notes

- The user code and data are preloaded at:
  - Code: `0x80001000`
  - Data: `0x80002000`

- The initial page table maps:
  - Virtual `0x00000000` → physical code page
  - Virtual `0x00001000` → physical data page

- All new mappings must be created at runtime based on the faulting address.

- Make use of relevant CSRs:
  - `mcause`, `mtval`, `mepc`, `satp`, and `mtvec`

---

#### Compilation & Execution

```bash
riscv64-unknown-elf-gcc -nostartfiles -T link.ld demand_paging.s -o demand_paging.out
spike -d demand_paging.out
